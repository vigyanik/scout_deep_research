# utils/formatter.py

import logging
import markdown
import re
import os
from typing import List, Dict, Tuple, Optional # Added Optional

# Assuming Reference schema is defined here or imported
try:
    from models.schemas import Reference # Needed if passing structured references
except ImportError:
    # Define a placeholder if schemas aren't available (e.g., if run standalone)
    class Reference:
        pass
    print("Warning: Could not import Reference schema from models.schemas.")


# Assuming get_timestamped_filename is moved to utils
try:
    from utils.helpers import get_timestamped_filename
except ImportError:
    print("Warning: Could not import get_timestamped_filename from utils.helpers.")
    from datetime import datetime
    def get_timestamped_filename(base, ext, ts=None):
        ts = ts or datetime.now().strftime("%Y%m%d_%H%M%S")
        return f"{base}_{ts}.{ext}" if base else f"{ts}.{ext}"


logger = logging.getLogger(__name__)

# --- Core Reference Processing Logic (Adapted from md_to_html_nav.py) ---

def _process_markdown_references(md_text: str) -> Tuple[str, Dict[str, Dict]]:
    """
    Replaces inline markdown links `[text](url)` with superscript numbered references `[n]`
    and builds a mapping of URLs to reference numbers and text.

    Args:
        md_text: The input markdown text containing inline links.

    Returns:
        A tuple containing:
            - new_md_text: Markdown text with links replaced by superscript refs.
            - ref_mapping: Dictionary {url: {'number': int, 'text': str, 'first_done': bool}}.
    """
    ref_mapping: Dict[str, Dict] = {}
    current_ref_number = [1] # Use list for mutable counter in nested function

    def replace_link(match):
        link_text = match.group(1)
        url = match.group(2)

        # Sanitize URL slightly (basic)
        url = url.strip()
        # Simple check if it looks like a URL, allows http/https and relative paths
        if not url or ('://' not in url and not url.startswith('/')):
             logger.warning(f"Skipping potentially invalid URL found in markdown: {url}")
             return match.group(0) # Return original match if URL looks invalid

        if url not in ref_mapping:
            ref_mapping[url] = {'number': current_ref_number[0], 'text': link_text, 'first_done': False}
            current_ref_number[0] += 1

        number = ref_mapping[url]['number']

        # Create superscript link to footnote
        # Use IDs for potential backlinking from footnote to first inline ref
        if not ref_mapping[url]['first_done']:
            ref_mapping[url]['first_done'] = True
            # First occurrence gets an ID
            return f'<sup id="ref-inline-{number}"><a href="#ref-footnote-{number}">[{number}]</a></sup>'
        else:
            # Subsequent occurrences don't need the ID
            return f'<sup><a href="#ref-footnote-{number}">[{number}]</a></sup>'

    # Regex to find markdown links: [text](url)
    # Allows more flexible URL characters, stops at space or closing parenthesis
    pattern = r'\[([^\]]+?)\]\(([^)\s]+)\)'
    try:
        processed_text = re.sub(pattern, replace_link, md_text)
    except Exception as e:
        logger.error(f"Error during regex substitution for references: {e}", exc_info=True)
        processed_text = md_text # Return original text on error

    return processed_text, ref_mapping


def _generate_references_html(ref_mapping: Dict[str, Dict]) -> str:
    """
    Creates an HTML unordered list of references sorted by number, with backlinks.

    Args:
        ref_mapping: The dictionary generated by _process_markdown_references.

    Returns:
        An HTML string containing the formatted references section, or empty string.
    """
    if not ref_mapping:
        return ""

    logger.debug(f"Generating HTML references for {len(ref_mapping)} unique URLs.")
    # Sort references by their assigned number
    sorted_refs = sorted(ref_mapping.items(), key=lambda item: item[1]['number'])

    ref_html = "\n<hr>\n<h2>References</h2>\n<ol>\n" # Changed to ordered list (ol)
    for url, data in sorted_refs:
        number = data['number']
        link_text = data['text'] # Original text from the first link instance
        # Basic HTML escaping for text and URL
        escaped_link_text = link_text.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')
        escaped_url = url.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;').replace('"', '&quot;')

        # Create list item with backlink to the first inline reference
        # Added target="_blank" rel="noopener noreferrer" for external links
        ref_html += f'  <li id="ref-footnote-{number}"><a href="#ref-inline-{number}" title="Back to content">^</a> {escaped_link_text} - <a href="{escaped_url}" target="_blank" rel="noopener noreferrer">{escaped_url}</a></li>\n'
    ref_html += "</ol>\n"
    return ref_html

def _convert_md_to_html_with_toc(md_text: str, toc_depth: str = "2-4") -> Tuple[str, str]:
    """
    Converts markdown text to HTML, including a Table of Contents. Uses common extensions.

    Args:
        md_text: Markdown text (potentially with reference markers already processed).
        toc_depth: String specifying TOC depth (e.g., "2-4"). Defaults to H2-H4.

    Returns:
        A tuple containing:
            - html_content: The main HTML body content.
            - toc_html: The HTML for the Table of Contents.
    """
    logger.debug("Converting markdown to HTML with TOC.")
    try:
         # Configure Markdown converter with TOC and other useful extensions
         md_converter = markdown.Markdown(
             extensions=[
                 "toc",
                 "fenced_code", # Support ```python ... ```
                 "tables",      # Support table syntax
                 "sane_lists",  # Improve list parsing behavior
                 "nl2br",       # Convert single newlines to <br> (optional, can make text dense)
                 "extra"        # Includes footnotes, abbr, def_list, etc.
                 ],
             output_format='html5', # Use HTML5 output
             extension_configs={
                 "toc": {
                     "toc_depth": toc_depth, # Control depth (e.g., '2-5')
                     "anchorlink": True, # Add anchor links to headings
                     "permalink": "#" # Symbol for permalink
                 }
             }
         )
         html_content = md_converter.convert(md_text)
         toc_html = md_converter.toc if hasattr(md_converter, 'toc') else ""
         logger.debug(f"HTML conversion complete. TOC generated: {'Yes' if toc_html else 'No'}")
         return html_content, toc_html
    except Exception as e:
         logger.error(f"Error converting markdown to HTML: {e}", exc_info=True)
         # Fallback: return plain text wrapped in pre tags
         # Basic escaping for HTML display
         escaped_md = md_text.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')
         return f"<h2>Report Content (Markdown Fallback)</h2><pre><code>{escaped_md}</code></pre>", "<p><i>Table of Contents generation failed.</i></p>"


def _build_full_html_page(title: str, toc_html: str, html_content: str, references_html: str) -> str:
    """
    Builds a complete HTML5 page with navigation, content, and references panes.
    Includes enhanced CSS for better readability.
    """
    logger.debug("Building full HTML page structure.")
    # Enhanced CSS for layout and typography
    css_styles = """
<style>
    :root {
        --text-color: #333;
        --bg-color: #fff;
        --nav-bg-color: #f8f9fa;
        --border-color: #dee2e6;
        --link-color: #007bff;
        --link-hover-color: #0056b3;
        --code-bg-color: #f1f3f5;
        --code-text-color: #c7254e; /* Bootstrap's default */
        --pre-bg-color: #f8f9fa;
    }
    html { scroll-behavior: smooth; }
    body { display: flex; margin: 0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; height: 100vh; font-size: 16px; background-color: var(--bg-color); color: var(--text-color); }
    nav#toc-nav { width: 300px; flex-shrink: 0; background: var(--nav-bg-color); padding: 20px; overflow-y: auto; border-right: 1px solid var(--border-color); box-sizing: border-box; height: 100vh; position: sticky; top: 0;}
    main#content-main { flex-grow: 1; padding: 25px 40px; overflow-y: auto; }
    nav#toc-nav h2 { margin-top: 0; font-size: 1.2em; color: #333; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; }
    a { text-decoration: none; color: var(--link-color); }
    a:hover { text-decoration: underline; color: var(--link-hover-color); }
    .toc ul { list-style: none; margin: 10px 0 0 0; padding-left: 0; }
    .toc li { margin: 6px 0; font-size: 0.9rem; line-height: 1.4;}
    .toc li a { color: #444; display: block; padding: 3px 5px; border-radius: 3px; transition: background-color 0.2s ease; }
    .toc li a:hover { background-color: #e9ecef; }
    .toc ul ul { padding-left: 15px; margin-top: 4px; border-left: 1px solid #e0e0e0;} /* Indent sub-levels */
    .references-section { margin-top: 40px; padding-top: 20px; border-top: 1px solid var(--border-color); }
    .references-section h2 { font-size: 1.3em; margin-bottom: 15px; }
    .references-section ol { list-style: decimal; padding-left: 25px; } /* Use ordered list */
    .references-section li { margin-bottom: 12px; font-size: 0.85rem; line-height: 1.5; color: #555; }
    .references-section li a[href^="#ref-inline"] { font-size: 0.75em; vertical-align: super; margin-right: 4px; background-color: #e0e0e0; padding: 1px 4px; border-radius: 3px; color: #333; }
    .references-section li a[href^="#ref-inline"]:hover { background-color: #ccc; }
    .references-section li a[target="_blank"] { word-break: break-all; } /* Break long URLs */
    h1, h2, h3, h4, h5, h6 { margin-top: 1.8em; margin-bottom: 0.6em; color: #111; font-weight: 600; line-height: 1.3; }
    h1 { font-size: 2.2em; border-bottom: 1px solid #eee; padding-bottom: 0.3em;}
    h2 { font-size: 1.7em; } h3 { font-size: 1.4em; } h4 { font-size: 1.2em; }
    p { line-height: 1.7; margin-bottom: 1em; color: var(--text-color); }
    strong, b { font-weight: 600; }
    ul, ol { padding-left: 25px; margin-bottom: 1em; } /* Applies to non-reference lists too */
    li { margin-bottom: 0.5em; }
    code { background-color: var(--code-bg-color); padding: 0.2em 0.4em; margin: 0; border-radius: 3px; font-family: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 85%; color: var(--code-text-color); }
    pre { background-color: var(--pre-bg-color); border: 1px solid var(--border-color); padding: 15px; border-radius: 5px; overflow-x: auto; font-size: 0.875em; line-height: 1.5; }
    pre code { background-color: transparent; padding: 0; border-radius: 0; border: none; color: inherit; font-size: 1em;} /* Reset style for code within pre */
    table { border-collapse: collapse; margin-bottom: 1.5em; width: auto; max-width: 100%; border: 1px solid #ccc; }
    th, td { border: 1px solid #ccc; padding: 10px 12px; text-align: left; vertical-align: top;}
    th { background-color: #f2f2f2; font-weight: 600; }
    tr:nth-child(even) { background-color: #f9f9f9; }
    blockquote { border-left: 4px solid var(--border-color); padding-left: 15px; margin-left: 0; margin-right: 0; color: #555; font-style: italic; }
    /* Markdown anchorlink style */
    .headerlink { margin-left: 0.5em; visibility: hidden; font-size: 0.8em; color: #aaa; }
    h1:hover .headerlink, h2:hover .headerlink, h3:hover .headerlink, h4:hover .headerlink, h5:hover .headerlink, h6:hover .headerlink { visibility: visible; }
    sup a { text-decoration: none; color: var(--link-color); font-weight: bold;}
    sup a:hover { color: var(--link-hover-color);}
</style>
"""
    html_template = f"""<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!--title>{title}</title-->
  <title>Research Report</title>
  {css_styles}
</head>
<body>
  <nav id="toc-nav">
    <h2>Navigation</h2>
    <div class="toc">
      {toc_html if toc_html else "<p><i>No table of contents generated.</i></p>"}
    </div>
  </nav>
  <main id="content-main">
    <!--h1>{title}</h1-->
    {html_content}
    <div class="references-section">
      {references_html if references_html else ""}
    </div>
  </main>
</body>
</html>"""
    return html_template

# --- Main Output Function ---

def write_output_files(
    final_markdown: str,
    output_base_filename: str, # e.g., "research_report" (without extension)
    output_dir: str,
    report_title: str = "Research Report" # Title for HTML page
    ) -> Tuple[Optional[str], Optional[str]]:
    """
    Processes the final markdown, generates HTML with TOC and formatted references,
    and writes both MD and HTML files to the specified output directory.

    Args:
        final_markdown: The complete markdown content generated by the research process.
        output_base_filename: The base name for the output files.
        output_dir: The directory path where files should be saved.
        report_title: The title to use for the HTML page.

    Returns:
        A tuple containing the full paths to the generated MD and HTML files.
        Returns (None, None) if writeup is empty or on error.
    """
    if not final_markdown or not final_markdown.strip():
         logger.warning("Final markdown content is empty. Skipping output file generation.")
         return None, None

    logger.info(f"Preparing to write output files for '{output_base_filename}' to directory '{output_dir}'")
    md_filepath = None
    html_filepath = None

    try:
         # Ensure output directory exists
         os.makedirs(output_dir, exist_ok=True)

         # Define exact filenames (no internal timestamping here)
         md_filepath = os.path.join(output_dir, f"{output_base_filename}.md")
         html_filepath = os.path.join(output_dir, f"{output_base_filename}.html")

         # --- Generate HTML ---
         # 1. Process inline references in the markdown
         processed_md_text, ref_mapping = _process_markdown_references(final_markdown)

         # 2. Generate HTML reference list section
         references_html_section = _generate_references_html(ref_mapping)

         # 3. Convert the processed markdown (with reference markers) to HTML body content + TOC
         html_content_body, toc_html = _convert_md_to_html_with_toc(processed_md_text)

         # 4. Build the full HTML page
         full_html_output = _build_full_html_page(report_title, toc_html, html_content_body, references_html_section)

         # --- Write Files ---
         # Write the final *original* markdown file (before reference processing)
         with open(md_filepath, "w", encoding='utf-8') as f_md:
             f_md.write(final_markdown)
         logger.info(f"Markdown output written to: {md_filepath}")

         # Write the generated HTML file
         with open(html_filepath, "w", encoding='utf-8') as f_html:
             f_html.write(full_html_output)
         logger.info(f"HTML output written to: {html_filepath}")

         return md_filepath, html_filepath

    except IOError as e:
         logger.error(f"Failed to write output files: {e}", exc_info=True)
         return None, None # Return None on error
    except Exception as e: # Catch other potential errors (e.g., in markdown processing)
         logger.error(f"An unexpected error occurred during output generation: {e}", exc_info=True)
         # Clean up potentially partially written files
         for f_path in [md_filepath, html_filepath]:
             if f_path and os.path.exists(f_path):
                 try:
                     os.remove(f_path)
                 except OSError:
                     logger.warning(f"Could not remove partially written file {f_path} after error.")
         return None, None # Return None on error